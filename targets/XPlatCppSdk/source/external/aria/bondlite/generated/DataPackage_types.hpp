//------------------------------------------------------------------------------
// This code was generated by a tool.
//
//   Tool : bondjson2cpp 2016.12.18.1
//   File : DataPackage.json
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// <auto-generated />
//------------------------------------------------------------------------------

#pragma once
#include <cstdint>
#include <string>
#include <vector>
#include <map>

namespace clienttelemetry {
namespace data {
namespace v3 {

struct ExceptionInfo {
    // 1: optional string Type
    std::string Type;
    // 2: optional string Message
    std::string Message;
    // 3: optional string FullInfo
    std::string FullInfo;

    bool operator==(ExceptionInfo const& other) const
    {
        return (Type == other.Type)
            && (Message == other.Message)
            && (FullInfo == other.FullInfo);
    }

    bool operator!=(ExceptionInfo const& other) const
    {
        return !(*this == other);
    }
};

struct Pstn {
    // 1: optional string PstnNumber
    std::string PstnNumber;
    // 2: optional string HashedPstn
    std::string HashedPstn;

    bool operator==(Pstn const& other) const
    {
        return (PstnNumber == other.PstnNumber)
            && (HashedPstn == other.HashedPstn);
    }

    bool operator!=(Pstn const& other) const
    {
        return !(*this == other);
    }
};

struct Endpoint {
    // 1: optional string EndpointValue
    std::string EndpointValue;
    // 2: optional string EndpointType
    std::string EndpointType;
    // 3: optional string HashedEndpoint
    std::string HashedEndpoint;

    bool operator==(Endpoint const& other) const
    {
        return (EndpointValue == other.EndpointValue)
            && (EndpointType == other.EndpointType)
            && (HashedEndpoint == other.HashedEndpoint);
    }

    bool operator!=(Endpoint const& other) const
    {
        return !(*this == other);
    }
};

struct User {
    // 1: optional string Username
    std::string Username;
    // 2: optional string Prefix
    std::string Prefix;
    // 3: optional string UiVersion
    std::string UiVersion;
    // 4: optional string Endpoint
    std::string Endpoint;
    // 5: optional string EndpointType
    std::string EndpointType;
    // 6: optional Pstn Pstn
    ::clienttelemetry::data::v3::Pstn Pstn;
    // 7: optional Endpoint EndpointComposite
    ::clienttelemetry::data::v3::Endpoint EndpointComposite;
    // 8: optional map<string, string> UserExtension
    std::map<std::string, std::string> UserExtension;
    // 9: optional string Email
    std::string Email;

    bool operator==(User const& other) const
    {
        return (Username == other.Username)
            && (Prefix == other.Prefix)
            && (UiVersion == other.UiVersion)
            && (Endpoint == other.Endpoint)
            && (EndpointType == other.EndpointType)
            && (Pstn == other.Pstn)
            && (EndpointComposite == other.EndpointComposite)
            && (UserExtension == other.UserExtension)
            && (Email == other.Email);
    }

    bool operator!=(User const& other) const
    {
        return !(*this == other);
    }
};

struct UserV1 {
    // 1: optional string Username
    std::string Username;
    // 2: optional string Prefix
    std::string Prefix;
    // 3: optional string UiVersion
    std::string UiVersion;
    // 4: optional string Endpoint
    std::string Endpoint;
    // 5: optional string EndpointType
    std::string EndpointType;
    // 6: optional Pstn Pstn
    ::clienttelemetry::data::v3::Pstn Pstn;
    // 7: optional Endpoint EndpointComposite
    ::clienttelemetry::data::v3::Endpoint EndpointComposite;
    // 8: optional map<string, string> UserExtension
    std::map<std::string, std::string> UserExtension;

    bool operator==(UserV1 const& other) const
    {
        return (Username == other.Username)
            && (Prefix == other.Prefix)
            && (UiVersion == other.UiVersion)
            && (Endpoint == other.Endpoint)
            && (EndpointType == other.EndpointType)
            && (Pstn == other.Pstn)
            && (EndpointComposite == other.EndpointComposite)
            && (UserExtension == other.UserExtension);
    }

    bool operator!=(UserV1 const& other) const
    {
        return !(*this == other);
    }
};

struct Conference {
    // 1: optional string ConferenceUri
    std::string ConferenceUri;
    // 2: optional string DomainName
    std::string DomainName;
    // 3: optional string UriScheme
    std::string UriScheme;

    bool operator==(Conference const& other) const
    {
        return (ConferenceUri == other.ConferenceUri)
            && (DomainName == other.DomainName)
            && (UriScheme == other.UriScheme);
    }

    bool operator!=(Conference const& other) const
    {
        return !(*this == other);
    }
};

namespace _bond_enumerators {
namespace RecordType {
enum RecordType {
    NotSet                  = 0,
    Event                   = 1,
    PerformanceCounter      = 2,
    Anomaly                 = 3,
    Prediction              = 4,
    TraceLog                = 5,
    EventSourceLog          = 6,
    HttpLog                 = 7,
    PerformanceCounterAzure = 8,
    PerformanceCounterGfs   = 9
};
}
}
using namespace _bond_enumerators::RecordType;

namespace _bond_enumerators {
namespace PIIScrubber {
enum PIIScrubber {
    NotSet    = 0,
    O365      = 1,
    SkypeBI   = 2,
    SkypeData = 3
};
}
}
using namespace _bond_enumerators::PIIScrubber;

namespace _bond_enumerators {
namespace PIIKind {
enum PIIKind {
    NotSet            = 0,
    DistinguishedName = 1,
    GenericData       = 2,
    IPV4Address       = 3,
    IPv6Address       = 4,
    MailSubject       = 5,
    PhoneNumber       = 6,
    QueryString       = 7,
    SipAddress        = 8,
    SmtpAddress       = 9,
    Identity          = 10,
    Uri               = 11,
    Fqdn              = 12,
    IPV4AddressLegacy = 13
};
}
}
using namespace _bond_enumerators::PIIKind;

struct PII {
    // 1: optional PIIScrubber ScrubType
    ::clienttelemetry::data::v3::PIIScrubber ScrubType = ::clienttelemetry::data::v3::PIIScrubber::NotSet;
    // 2: optional PIIKind Kind
    ::clienttelemetry::data::v3::PIIKind Kind = ::clienttelemetry::data::v3::PIIKind::NotSet;
    // 3: optional string RawContent
    std::string RawContent;

    bool operator==(PII const& other) const
    {
        return (ScrubType == other.ScrubType)
            && (Kind == other.Kind)
            && (RawContent == other.RawContent);
    }

    bool operator!=(PII const& other) const
    {
        return !(*this == other);
    }
};

struct Record {
    // 1: optional string Id
    std::string Id;
    // 2: optional vector<string> Context
    std::vector<std::string> Context;
    // 3: optional int64 Timestamp
    int64_t Timestamp = 0;
    // 4: optional map<string, string> ConfigurationIds
    std::map<std::string, std::string> ConfigurationIds;
    // 5: optional string Type
    std::string Type;
    // 6: optional string EventType
    std::string EventType;
    // 7: optional int32 ResultCode
    int32_t ResultCode = 0;
    // 8: optional string ResultDetail
    std::string ResultDetail;
    // 9: optional string ResultValue
    std::string ResultValue;
    // 10: optional string InitiatingUser
    std::string InitiatingUser;
    // 11: optional string InitiatingUserEndpoint
    std::string InitiatingUserEndpoint;
    // 12: optional vector<string> TargetUsers
    std::vector<std::string> TargetUsers;
    // 13: optional map<string, string> Extension
    std::map<std::string, std::string> Extension;
    // 14: optional int64 SampleTimestamp
    int64_t SampleTimestamp = 0;
    // 15: optional string SampleRate
    std::string SampleRate;
    // 16: optional map<string, vector<int64>> SamplingData
    std::map<std::string, std::vector<int64_t>> SamplingData;
    // 17: optional string InitiatingUiVersion
    std::string InitiatingUiVersion;
    // 18: optional map<string, string> PstnNumbers
    std::map<std::string, std::string> PstnNumbers;
    // 19: optional map<string, string> ContextIds
    std::map<std::string, std::string> ContextIds;
    // 20: optional string InitiatingUserEndpointType
    std::string InitiatingUserEndpointType;
    // 21: optional UserV1 DeprecatedInitiatingUserComposite
    ::clienttelemetry::data::v3::UserV1 DeprecatedInitiatingUserComposite;
    // 22: optional vector<UserV1> DeprecatedTargetUsersComposite
    std::vector< ::clienttelemetry::data::v3::UserV1> DeprecatedTargetUsersComposite;
    // 23: optional map<string, Pstn> PstnNumbersComposite
    std::map<std::string, ::clienttelemetry::data::v3::Pstn> PstnNumbersComposite;
    // 24: optional RecordType RecordType
    ::clienttelemetry::data::v3::RecordType RecordType = ::clienttelemetry::data::v3::RecordType::NotSet;
    // 25: optional map<string, int64> ExtensionInt64
    std::map<std::string, int64_t> ExtensionInt64;
    // 26: optional map<string, double> _reserved
    std::map<std::string, double> _reserved;
    // 28: optional Conference ConferenceComposite
    ::clienttelemetry::data::v3::Conference ConferenceComposite;
    // 29: optional ExceptionInfo ExceptionInfo
    ::clienttelemetry::data::v3::ExceptionInfo ExceptionInfo;
    // 30: optional map<string, PII> PIIExtensions
    std::map<std::string, ::clienttelemetry::data::v3::PII> PIIExtensions;
    // 31: optional User InitiatingUserComposite
    ::clienttelemetry::data::v3::User InitiatingUserComposite;
    // 32: optional vector<User> TargetUsersComposite
    std::vector< ::clienttelemetry::data::v3::User> TargetUsersComposite;

    bool operator==(Record const& other) const
    {
        return (Id == other.Id)
            && (Context == other.Context)
            && (Timestamp == other.Timestamp)
            && (ConfigurationIds == other.ConfigurationIds)
            && (Type == other.Type)
            && (EventType == other.EventType)
            && (ResultCode == other.ResultCode)
            && (ResultDetail == other.ResultDetail)
            && (ResultValue == other.ResultValue)
            && (InitiatingUser == other.InitiatingUser)
            && (InitiatingUserEndpoint == other.InitiatingUserEndpoint)
            && (TargetUsers == other.TargetUsers)
            && (Extension == other.Extension)
            && (SampleTimestamp == other.SampleTimestamp)
            && (SampleRate == other.SampleRate)
            && (SamplingData == other.SamplingData)
            && (InitiatingUiVersion == other.InitiatingUiVersion)
            && (PstnNumbers == other.PstnNumbers)
            && (ContextIds == other.ContextIds)
            && (InitiatingUserEndpointType == other.InitiatingUserEndpointType)
            && (DeprecatedInitiatingUserComposite == other.DeprecatedInitiatingUserComposite)
            && (DeprecatedTargetUsersComposite == other.DeprecatedTargetUsersComposite)
            && (PstnNumbersComposite == other.PstnNumbersComposite)
            && (RecordType == other.RecordType)
            && (ExtensionInt64 == other.ExtensionInt64)
            && (_reserved == other._reserved)
            && (ConferenceComposite == other.ConferenceComposite)
            && (ExceptionInfo == other.ExceptionInfo)
            && (PIIExtensions == other.PIIExtensions)
            && (InitiatingUserComposite == other.InitiatingUserComposite)
            && (TargetUsersComposite == other.TargetUsersComposite);
    }

    bool operator!=(Record const& other) const
    {
        return !(*this == other);
    }
};

struct DataPackage {
    // 1: optional string Type
    std::string Type;
    // 2: optional string Source
    std::string Source;
    // 3: optional string Version
    std::string Version;
    // 4: optional map<string, string> Ids
    std::map<std::string, std::string> Ids;
    // 5: optional string DataPackageId
    std::string DataPackageId;
    // 6: optional int64 Timestamp
    int64_t Timestamp = 0;
    // 7: optional int32 SchemaVersion
    int32_t SchemaVersion = 0;
    // 8: optional vector<Record> Records
    std::vector< ::clienttelemetry::data::v3::Record> Records;
    // 9: optional vector<Record> Receipts
    std::vector< ::clienttelemetry::data::v3::Record> Receipts;

    bool operator==(DataPackage const& other) const
    {
        return (Type == other.Type)
            && (Source == other.Source)
            && (Version == other.Version)
            && (Ids == other.Ids)
            && (DataPackageId == other.DataPackageId)
            && (Timestamp == other.Timestamp)
            && (SchemaVersion == other.SchemaVersion)
            && (Records == other.Records)
            && (Receipts == other.Receipts);
    }

    bool operator!=(DataPackage const& other) const
    {
        return !(*this == other);
    }
};

struct ClientToCollectorRequest {
    // 1: optional vector<DataPackage> DataPackages
    std::vector< ::clienttelemetry::data::v3::DataPackage> DataPackages;
    // 2: optional int32 RequestRetryCount
    int32_t RequestRetryCount = 0;

    bool operator==(ClientToCollectorRequest const& other) const
    {
        return (DataPackages == other.DataPackages)
            && (RequestRetryCount == other.RequestRetryCount);
    }

    bool operator!=(ClientToCollectorRequest const& other) const
    {
        return !(*this == other);
    }
};

} // namespace v3
} // namespace data
} // namespace clienttelemetry
