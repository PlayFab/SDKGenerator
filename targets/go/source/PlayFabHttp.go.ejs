package playfab

// This code was generated by a tool. Any changes may be overwritten

import (
	"bytes"
	"compress/gzip"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"reflect"
	"strings"
	"time"
)

type playFabResponse struct {
	Code   int                    `json:"code"`
	Status string                 `json:"status"`
	Data   map[string]interface{} `json:"data"`
}

// CustomError contains data about an error during HTTP operation
type CustomError struct {
	msg  string
	Code ErrorCode
}

func (p *CustomError) Error() string { return p.msg }

// NewCustomError returns a new CustomError with a message and an error code
func NewCustomError(msg string, code ErrorCode) *CustomError {
	return &CustomError{msg: msg, Code: code}
}

// ErrorCode is a custom error code
type ErrorCode int

const (
	// ErrorUnmarshal is an error during response unmarshaling
	ErrorUnmarshal ErrorCode = iota
	// ErrorGZIP is an error during GZIPing
	ErrorGZIP
	// ErrorCreateRequest is an error during request creation
	ErrorCreateRequest
	// ErrorDoRequest is an error during request execution
	ErrorDoRequest
	// ErrorMarshal is an error during POST data marshaling
	ErrorMarshal
	// ErrorDecoding is an error that occurs during map[string]interface{} -> struct creation
	ErrorDecoding
	// ErrorGeneric represents a generic error
	ErrorGeneric
)

// AdType
type AdType string

const (
	AdTypeIdfa                AdType = "Idfa"
	AdTypeAndroidId           AdType = "Adid"
	AdTypeIdfaSuccessful      AdType = "Idfa_Successful"
	AdTypeAndroidIdSuccessful AdType = "Adid_Successful"
)

// Settings includes various conf options for PlayFab HTTP call
type Settings struct {
	VersionString            string
	RequestGetParams         map[string]string
	ProductionEnvironmentURL string
	EnableCompression        bool
	VerticalName             string
	TitleId                  string
	DisableSsl               bool
	APIPath                  string
	AdvertisingIdType        AdType
	AdvertisingIdValue       string
	DisableAdvertising       bool
}

// NewSettingsWithDefaultOptions  returns a pointer to a Settings struct that carries default values
// Requires a valid titleId
func NewSettingsWithDefaultOptions(titleId string) *Settings {
	return &Settings{
		VersionString:            "GoSdk-<%- sdkVersion %>",
		RequestGetParams:         map[string]string{"sdk": "<%- sdkVersion %>"},
		ProductionEnvironmentURL: ".playfabapi.com", // This is only for customers running a private cluster.  Generally you shouldn't touch this
		EnableCompression:        false,
		VerticalName:             "<%- getVerticalNameDefault() %>", // The name of a customer vertical. This is only for customers running a private cluster. Generally you shouldn't touch this
		TitleId:                  titleId,
		DisableSsl:               false,
		DisableAdvertising:       false,
	}
}

// getFullURL returns the full URL to be used for the API call
func (p *Settings) getFullURL(apiPath string) string {
	var output string

	if !strings.HasPrefix(p.ProductionEnvironmentURL, "http") {
		if p.VerticalName != "" {
			output = "https://" + p.VerticalName
		} else {
			output = "https://" + p.TitleId
		}
	}

	output += p.ProductionEnvironmentURL
	output += apiPath

	firstParam := true
	for key, val := range p.RequestGetParams {
		if firstParam {
			output += "?"
			firstParam = false
		} else {
			output += "&"
		}
		output += fmt.Sprintf("%s=%s", key, val)
	}

	return output
}

// Request executes the actual HTTP call
func Request(p *Settings, b []byte, apiPath string, authKey string, authValue string) (map[string]interface{}, error) {
	client := &http.Client{
		Timeout: time.Second * 30, // 30 seconds timeout should be enough
	}

	if p.DisableSsl {
		client.Transport = &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		}
	}

	var req *http.Request
	var err error

	// compression enabled, so gzip POST data
	if p.EnableCompression {
		var buf bytes.Buffer
		zw := gzip.NewWriter(&buf)
		if _, err := zw.Write(b); err != nil {
			return nil, NewCustomError(err.Error(), ErrorGZIP)
		}
		if err := zw.Flush(); err != nil {
			return nil, NewCustomError(err.Error(), ErrorGZIP)
		}
		if err := zw.Close(); err != nil {
			return nil, NewCustomError(err.Error(), ErrorGZIP)
		}
		req, err = http.NewRequest("POST", p.getFullURL(apiPath), &buf)
		if err != nil {
			return nil, NewCustomError(err.Error(), ErrorCreateRequest)
		}
		req.Header.Add("Content-Encoding", "GZIP")
	} else {
		req, err = http.NewRequest("POST", p.getFullURL(apiPath), bytes.NewBuffer(b))
		if err != nil {
			return nil, NewCustomError(err.Error(), ErrorCreateRequest)
		}
	}

	req.Header.Add("Content-Type", "application/json")
	req.Header.Add("X-ReportErrorAsSuccess", "true")
	req.Header.Add("X-PlayFabSDK", p.VersionString)

	if authKey != "" && authValue != "" {
		req.Header.Add(authKey, authValue)
	}

	resp, err := client.Do(req)
	if err != nil {
		return nil, NewCustomError(err.Error(), ErrorDoRequest)
	}
	defer resp.Body.Close()

	bodyBytes, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, NewCustomError(err.Error(), ErrorDoRequest)
	}

	result := playFabResponse{}
	err = json.Unmarshal(bodyBytes, &result)
	if err != nil {
		return nil, NewCustomError(err.Error(), ErrorUnmarshal)
	}

	if result.Code != 200 {
		errorString := fmt.Sprintf("error code %d", result.Code)
		if result.Status != "" {
			errorString = fmt.Sprintf("%s and status %s", errorString, result.Status)
		}
		return nil, NewCustomError(errorString, ErrorDoRequest)
	}

	return result.Data, nil
}

// StringToDateTimeHook is used with mapstructure package to correctly unmarshal time fields
// https://github.com/mitchellh/mapstructure/issues/41
func StringToDateTimeHook(f reflect.Type, t reflect.Type, data interface{}) (interface{}, error) {
	if t == reflect.TypeOf(time.Time{}) && f == reflect.TypeOf("") {
		return time.Parse(time.RFC3339, data.(string))
	}
	return data, nil
}
